# Session 5: 성능 튜닝과 비용 최적화

## 📍 교과과정에서의 위치
이 세션은 **Week 3 > Day 5 > Session 5**로, Kubernetes 클러스터의 성능 튜닝과 비용 최적화 전략을 학습합니다.

## 학습 목표 (5분)
- **클러스터 성능 분석**과 **튜닝** 방법 이해
- **리소스 사용률 최적화**와 **효율성** 향상 기법 학습
- **클라우드 비용 관리** 전략과 **비용 최적화** 방법 파악
- **스팟 인스턴스**와 **예약 인스턴스** 활용 전략 습득

## 1. 클러스터 성능 분석과 튜닝 (12분)

### 성능 모니터링 아키텍처

```mermaid
graph TB
    subgraph "성능 모니터링"
        A[Cluster Metrics] --> B[Node Metrics]
        A --> C[Pod Metrics]
        A --> D[Application Metrics]
        
        E[Resource Usage] --> F[CPU Utilization]
        E --> G[Memory Usage]
        E --> H[Network I/O]
        E --> I[Storage I/O]
        
        J[Performance Analysis] --> K[Bottleneck Detection]
        J --> L[Capacity Planning]
        J --> M[Optimization Recommendations]
    end
```

### 성능 분석 및 튜닝 상세 가이드

```
Kubernetes 성능 분석 및 튜닝:

1. 성능 메트릭 수집 및 분석:
├── 클러스터 레벨 메트릭:
│   ├── 전체 리소스 사용률:
│   │   ├── CPU 사용률 (전체 클러스터 대비)
│   │   ├── 메모리 사용률 (전체 클러스터 대비)
│   │   ├── 스토리지 사용률 (PV/PVC 기준)
│   │   └── 네트워크 대역폭 사용률
│   ├── 클러스터 상태 메트릭:
│   │   ├── 노드 Ready/NotReady 상태
│   │   ├── Pod 스케줄링 성공/실패율
│   │   ├── API Server 응답 시간
│   │   └── etcd 성능 지표
│   ├── 스케줄링 효율성:
│   │   ├── Pending Pod 수 및 원인
│   │   ├── 리소스 단편화 정도
│   │   ├── 노드 간 부하 분산 상태
│   │   └── 어피니티/안티어피니티 효과
│   └── 확장성 지표:
│       ├── 오토스케일링 반응 시간
│       ├── 노드 추가/제거 시간
│       ├── Pod 시작 시간
│       └── 서비스 디스커버리 지연
├── 노드 레벨 메트릭:
│   ├── 하드웨어 리소스:
│   │   ├── CPU 사용률 (코어별, 프로세스별)
│   │   ├── 메모리 사용률 (사용/캐시/버퍼)
│   │   ├── 디스크 I/O (읽기/쓰기 IOPS, 처리량)
│   │   └── 네트워크 I/O (패킷/바이트 수)
│   ├── 시스템 성능:
│   │   ├── Load Average (1분, 5분, 15분)
│   │   ├── Context Switch 빈도
│   │   ├── 인터럽트 처리 시간
│   │   └── 시스템 콜 지연시간
│   ├── 컨테이너 런타임:
│   │   ├── Docker/containerd 성능
│   │   ├── 이미지 풀 시간
│   │   ├── 컨테이너 시작/중지 시간
│   │   └── 오버레이 파일시스템 성능
│   └── 네트워크 성능:
│       ├── CNI 플러그인 성능
│       ├── 서비스 메시 오버헤드
│       ├── DNS 해상도 시간
│       └── 로드밸런싱 지연
├── Pod 레벨 메트릭:
│   ├── 리소스 사용량:
│   │   ├── CPU 사용률 (요청/제한 대비)
│   │   ├── 메모리 사용률 (요청/제한 대비)
│   │   ├── 임시 스토리지 사용량
│   │   └── 네트워크 트래픽 패턴
│   ├── 애플리케이션 성능:
│   │   ├── 응답 시간 (P50, P95, P99)
│   │   ├── 처리량 (RPS, TPS)
│   │   ├── 에러율 및 실패 패턴
│   │   └── 큐 길이 및 대기 시간
│   ├── 라이프사이클 메트릭:
│   │   ├── Pod 시작 시간
│   │   ├── 준비 상태 도달 시간
│   │   ├── 재시작 빈도 및 원인
│   │   └── 종료 시간 (Graceful shutdown)
│   └── 의존성 성능:
│       ├── 외부 서비스 호출 지연
│       ├── 데이터베이스 쿼리 시간
│       ├── 캐시 히트율
│       └── 메시지 큐 처리 시간
└── 애플리케이션 레벨 메트릭:
    ├── 비즈니스 메트릭:
    │   ├── 사용자 세션 수
    │   ├── 트랜잭션 처리량
    │   ├── 비즈니스 로직 처리 시간
    │   └── 사용자 경험 지표
    ├── 기술적 메트릭:
    │   ├── JVM/런타임 성능 (해당시)
    │   ├── 가비지 컬렉션 시간
    │   ├── 스레드 풀 사용률
    │   └── 커넥션 풀 상태
    ├── 보안 메트릭:
    │   ├── 인증/인가 처리 시간
    │   ├── TLS 핸드셰이크 지연
    │   ├── 보안 스캔 결과
    │   └── 취약점 탐지 알림
    └── 데이터 메트릭:
        ├── 데이터 처리량
        ├── 데이터 품질 지표
        ├── 백업/복구 성능
        └── 데이터 일관성 검증

2. 성능 병목 지점 식별:
├── CPU 병목:
│   ├── 증상:
│   │   ├── 높은 CPU 사용률 (>80%)
│   │   ├── 높은 Load Average
│   │   ├── Context Switch 증가
│   │   └── 응답 시간 증가
│   ├── 원인 분석:
│   │   ├── CPU 집약적 워크로드
│   │   ├── 비효율적인 알고리즘
│   │   ├── 무한 루프 또는 데드락
│   │   └── 부적절한 리소스 할당
│   ├── 해결 방안:
│   │   ├── CPU 리소스 증가
│   │   ├── 워크로드 분산
│   │   ├── 알고리즘 최적화
│   │   └── 캐싱 전략 도입
│   └── 모니터링:
│       ├── CPU 사용률 추이
│       ├── 프로세스별 CPU 사용량
│       ├── 스레드 덤프 분석
│       └── 프로파일링 도구 활용
├── 메모리 병목:
│   ├── 증상:
│   │   ├── 높은 메모리 사용률 (>85%)
│   │   ├── OOMKilled 이벤트 발생
│   │   ├── 스왑 사용량 증가
│   │   └── 가비지 컬렉션 빈발
│   ├── 원인 분석:
│   │   ├── 메모리 누수
│   │   ├── 대용량 데이터 처리
│   │   ├── 캐시 크기 부적절
│   │   └── 메모리 리소스 부족
│   ├── 해결 방안:
│   │   ├── 메모리 리소스 증가
│   │   ├── 메모리 누수 수정
│   │   ├── 캐시 정책 최적화
│   │   └── 데이터 처리 방식 개선
│   └── 모니터링:
│       ├── 메모리 사용률 패턴
│       ├── 힙 덤프 분석
│       ├── 가비지 컬렉션 로그
│       └── 메모리 프로파일링
├── 네트워크 병목:
│   ├── 증상:
│   │   ├── 높은 네트워크 지연
│   │   ├── 패킷 드롭 발생
│   │   ├── 대역폭 포화
│   │   └── DNS 해상도 지연
│   ├── 원인 분석:
│   │   ├── 네트워크 대역폭 부족
│   │   ├── CNI 플러그인 성능 이슈
│   │   ├── 서비스 메시 오버헤드
│   │   └── 네트워크 정책 복잡성
│   ├── 해결 방안:
│   │   ├── 네트워크 대역폭 증가
│   │   ├── CNI 플러그인 최적화
│   │   ├── 트래픽 라우팅 개선
│   │   └── 캐싱 전략 강화
│   └── 모니터링:
│       ├── 네트워크 트래픽 패턴
│       ├── 지연시간 분포
│       ├── 패킷 손실률
│       └── 대역폭 사용률
└── 스토리지 병목:
    ├── 증상:
    │   ├── 높은 디스크 I/O 대기
    │   ├── 스토리지 응답 시간 증가
    │   ├── 디스크 큐 길이 증가
    │   └── 파일시스템 성능 저하
    ├── 원인 분석:
    │   ├── 디스크 I/O 집약적 워크로드
    │   ├── 스토리지 성능 한계
    │   ├── 파일시스템 단편화
    │   └── 부적절한 스토리지 클래스
    ├── 해결 방안:
    │   ├── 고성능 스토리지 사용
    │   ├── I/O 패턴 최적화
    │   ├── 캐싱 레이어 추가
    │   └── 스토리지 클래스 변경
    └── 모니터링:
        ├── 디스크 I/O 메트릭
        ├── 스토리지 지연시간
        ├── 처리량 패턴
        └── 파일시스템 상태

3. 성능 튜닝 전략:
├── 리소스 최적화:
│   ├── Right-sizing:
│   │   ├── 실제 사용량 기반 리소스 조정
│   │   ├── 과도한 리소스 할당 방지
│   │   ├── 리소스 요청/제한 최적화
│   │   └── 주기적인 사용량 검토
│   ├── 수직 확장 (Vertical Scaling):
│   │   ├── CPU/메모리 증가
│   │   ├── VPA 활용한 자동 조정
│   │   ├── 성능 테스트 기반 결정
│   │   └── 비용 대비 효과 분석
│   ├── 수평 확장 (Horizontal Scaling):
│   │   ├── 레플리카 수 증가
│   │   ├── HPA 설정 최적화
│   │   ├── 로드 분산 개선
│   │   └── 상태 관리 고려
│   └── 리소스 할당 정책:
│       ├── QoS 클래스 최적화
│       ├── 우선순위 클래스 설정
│       ├── 리소스 쿼터 관리
│       └── LimitRange 정책
├── 스케줄링 최적화:
│   ├── 노드 어피니티:
│   │   ├── 하드웨어 특성 기반 배치
│   │   ├── 지역/가용영역 고려
│   │   ├── 성능 요구사항 매칭
│   │   └── 비용 효율성 고려
│   ├── Pod 어피니티/안티어피니티:
│   │   ├── 관련 서비스 근접 배치
│   │   ├── 고가용성을 위한 분산
│   │   ├── 네트워크 지연 최소화
│   │   └── 리소스 경합 방지
│   ├── 테인트와 톨러레이션:
│   │   ├── 전용 노드 활용
│   │   ├── 특수 워크로드 격리
│   │   ├── 유지보수 시 배제
│   │   └── 하드웨어 장애 대응
│   └── 커스텀 스케줄러:
│       ├── 특수 요구사항 대응
│       ├── 비즈니스 로직 반영
│       ├── 고급 배치 전략
│       └── 성능 최적화 알고리즘
├── 네트워크 최적화:
│   ├── CNI 플러그인 선택:
│   │   ├── 성능 벤치마크 비교
│   │   ├── 기능 요구사항 매칭
│   │   ├── 운영 복잡성 고려
│   │   └── 보안 요구사항 충족
│   ├── 서비스 메시 최적화:
│   │   ├── 사이드카 리소스 튜닝
│   │   ├── 트래픽 정책 최적화
│   │   ├── 관찰 가능성 설정
│   │   └── 보안 정책 균형
│   ├── 로드 밸런싱:
│   │   ├── 알고리즘 선택 최적화
│   │   ├── 헬스체크 설정 조정
│   │   ├── 세션 어피니티 고려
│   │   └── 트래픽 분산 전략
│   └── DNS 최적화:
│       ├── CoreDNS 설정 튜닝
│       ├── DNS 캐싱 전략
│       ├── 외부 DNS 연동
│       └── DNS 정책 최적화
└── 애플리케이션 최적화:
    ├── 컨테이너 이미지:
    │   ├── 멀티스테이지 빌드 활용
    │   ├── 베이스 이미지 최적화
    │   ├── 레이어 캐싱 전략
    │   └── 보안 스캔 통합
    ├── 시작 시간 최적화:
    │   ├── Init Container 활용
    │   ├── 의존성 사전 로딩
    │   ├── 설정 외부화
    │   └── 헬스체크 최적화
    ├── 리소스 사용 패턴:
    │   ├── 메모리 사용 최적화
    │   ├── CPU 사용 패턴 개선
    │   ├── I/O 최적화
    │   └── 캐싱 전략 구현
    └── 관찰 가능성:
        ├── 메트릭 수집 최적화
        ├── 로깅 전략 개선
        ├── 트레이싱 구현
        └── 프로파일링 도구 활용
```

### 비용 최적화 전략

```mermaid
graph TB
    subgraph "비용 최적화 전략"
        A[Right-sizing] --> B[Resource Optimization]
        A --> C[Workload Efficiency]
        
        D[Instance Types] --> E[Spot Instances]
        D --> F[Reserved Instances]
        D --> G[Savings Plans]
        
        H[Scheduling] --> I[Node Affinity]
        H --> J[Pod Packing]
        H --> K[Cluster Autoscaling]
        
        L[Cost Monitoring] --> M[Resource Tagging]
        L --> N[Cost Allocation]
        L --> O[Budget Alerts]
    end
```

### 비용 최적화 실무 가이드

```
클라우드 비용 최적화 핵심 전략:

1. 스팟 인스턴스 활용:
├── 개념: 여유 인스턴스를 저렴한 가격에 사용 (50-90% 절약)
├── 적용 워크로드: 상태 비저장, 배치 처리, 개발/테스트
├── 구현 전략: 다양한 인스턴스 타입 혼합, 자동 대체
└── 주의사항: 중단 대비 전략 필수

2. 예약 인스턴스:
├── 1-3년 약정으로 30-60% 절약
├── 예측 가능한 워크로드에 적합
├── 전체 선불 vs 부분 선불 옵션
└── 활용률 모니터링 필수

3. Right-sizing:
├── 실제 사용량 기반 리소스 조정
├── VPA 활용한 자동 최적화
├── 과도한 할당 30-50% 비용 절약
└── 주기적 리뷰 및 조정

4. 비용 모니터링:
├── 리소스 태깅으로 비용 할당
├── 실시간 비용 대시보드
├── 예산 초과 알림 시스템
└── 비용 최적화 권장사항 자동 생성
```

## 💬 그룹 토론: 성능 vs 비용 최적화 균형점 (8분)

### 토론 주제
**"클러스터 성능을 유지하면서도 비용을 최적화하는 균형점을 찾기 위한 전략은 무엇인가?"**

### 토론 가이드라인

#### 성능 요구사항 (3분)
- **SLA 준수**: 서비스 수준 협약 유지
- **사용자 경험**: 응답 시간과 가용성
- **확장성**: 트래픽 증가 대응 능력

#### 비용 최적화 방법 (3분)
- **리소스 효율성**: 적절한 크기 조정
- **인스턴스 전략**: 스팟, 예약 인스턴스 활용
- **자동화**: 스케일링과 스케줄링 최적화

#### 균형점 찾기 (2분)
- **우선순위**: 성능과 비용의 우선순위 설정
- **측정 지표**: 효과를 측정할 수 있는 KPI
- **지속적 개선**: 모니터링과 최적화 프로세스

## 💡 핵심 개념 정리
- **성능 튜닝**: 클러스터 메트릭 분석, 병목 지점 식별, 최적화
- **리소스 최적화**: Right-sizing, 효율적 스케줄링, 자동 스케일링
- **비용 관리**: 인스턴스 전략, 리소스 태깅, 예산 관리
- **균형점**: 성능 요구사항과 비용 효율성의 최적 조합

## 📚 참고 자료
- [Kubernetes Performance Tuning](https://kubernetes.io/docs/concepts/cluster-administration/system-metrics/)
- [Cloud Cost Optimization](https://aws.amazon.com/aws-cost-management/)
- [Spot Instance Best Practices](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-best-practices.html)
- [Resource Management Guide](https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/)

## 다음 세션 준비
다음 세션에서는 **트러블슈팅과 문제 해결**에 대해 학습합니다. 일반적인 Kubernetes 문제 패턴과 디버깅 기법을 다룰 예정입니다.