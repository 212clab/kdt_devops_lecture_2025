# Session 7: ConfigMap과 Secret 관리

## 📍 교과과정에서의 위치
이 세션은 **Week 2 > Day 5 > Session 7**로, 스토리지 학습 후 애플리케이션 **설정 관리**와 **민감 정보 보호**를 위한 ConfigMap과 Secret 활용 방법을 학습합니다.

## 학습 목표 (5분)
- **ConfigMap**과 **Secret**의 **차이점**과 **사용 목적** 완전 이해
- **설정 데이터 분리**와 **12-Factor App** 원칙 적용
- **민감 정보 보안**과 **암호화** 메커니즘 분석
- **설정 관리 모범 사례**와 **운영 전략** 수립

## 1. ConfigMap 아키텍처와 활용 (15분)

### ConfigMap 구조와 사용 패턴

```mermaid
graph TB
    subgraph "설정 소스"
        A[환경 변수] --> B[ConfigMap]
        C[설정 파일] --> B
        D[명령행 인수] --> B
    end
    
    subgraph "ConfigMap 저장"
        B --> E[Key-Value 쌍]
        B --> F[파일 내용]
        B --> G[바이너리 데이터]
    end
    
    subgraph "Pod 사용"
        H[환경 변수로 주입] --> I[Container]
        J[볼륨으로 마운트] --> I
        K[명령행 인수] --> I
    end
    
    E --> H
    F --> J
    G --> J
```

### ConfigMap 상세 분석
```
ConfigMap 설정 관리 아키텍처:

ConfigMap 기본 개념:
   🔹 설정 데이터와 코드 분리
   🔹 12-Factor App 원칙 준수
   🔹 환경별 설정 관리
   🔹 런타임 설정 변경
   🔹 네임스페이스 스코프
   🔹 키-값 쌍 저장

ConfigMap 데이터 타입:
   🔹 단순 키-값 쌍:
      • 환경 변수 형태
      • 애플리케이션 매개변수
      • 기능 플래그
      • API 엔드포인트
      • 타임아웃 설정
      • 로그 레벨 설정
   🔹 설정 파일:
      • application.properties
      • config.yaml
      • nginx.conf
      • database.ini
      • logging.xml
      • 커스텀 설정 파일
   🔹 바이너리 데이터:
   🔹 인증서 파일
   🔹 키 파일
   🔹 이미지 파일
   🔹 압축 파일
   🔹 실행 파일

ConfigMap 사용 패턴 및 베스트 프랙티스:
   🔹 환경 변수 주입 패턴:
      • 전체 ConfigMap 주입 (envFrom):
         • 모든 키-값 쌍을 환경변수로 노출
         • 대량 설정 일괄 적용
         • 설정 네임스페이스 분리
         • 자동 업데이트 지원
         • 이름 충돌 방지 전략
         • 성능 최적화 고려
      • 선택적 키 주입 (env):
         • 필요한 설정만 선택적 노출
         • 보안 강화 (민감 정보 제외)
         • 이름 매핑 및 변환
         • 기본값 설정 지원
         • 조건부 설정 적용
         • 유효성 검증 지원
      • 환경별 오버라이드 전략:
         • 기본 설정 + 환경별 오버라이드
         • 우선순위 기반 설정 병합
         • 조건부 설정 적용
         • 프로파일 기반 설정
         • 다단계 상속 구조
         • 동적 환경 감지
      • 설정 검증 및 기본값:
         • 스키마 기반 설정 검증
         • 필수 설정 강제 검사
         • 데이터 타입 및 범위 검증
         • 기본값 자동 설정
         • 설정 상호 의존성 검사
         • 오류 처리 및 로깅
      • 동적 설정 업데이트:
      • ConfigMap 변경 감지
      • 애플리케이션 재시작 전략
      • 무중단 설정 업데이트
      • 설정 새로고침 신호
      • 롤링 업데이트 지원
      • 설정 변경 알림
   🔹 볼륨 마운트 패턴:
      • 전체 파일 마운트:
         • ConfigMap의 모든 키를 파일로 마운트
         • 디렉토리 구조 자동 생성
         • 파일 권한 자동 설정
         • 심볼릭 링크 지원
         • 실시간 업데이트 반영
         • 대용량 설정 파일 지원
      • 선택적 파일 마운트:
         • 특정 키만 파일로 마운트
         • 파일 이름 커스터마이징
         • 경로 지정 및 매핑
         • 권한 세밀 제어
         • 중복 파일 방지
         • 조건부 마운트
      • subPath 활용 패턴:
         • 기존 디렉토리 내 파일 추가
         • 설정 파일 부분 업데이트
         • 다중 ConfigMap 병합
         • 레거시 시스템 통합
         • 점진적 마이그레이션
         • 설정 충돌 해결
      • 읽기 전용 마운트:
         • 보안 강화 (수정 방지)
         • 실수로 인한 설정 변경 방지
         • 성능 최적화 (캐시 활용)
         • 다중 컨테이너 공유
         • 일관성 보장
      • 마운트 옵션 최적화:
      • 파일 권한 세밀 설정
      • 소유자 및 그룹 설정
      • 심볼릭 링크 정책
      • 업데이트 전파 설정
      • 캐시 및 성능 옵션
   🔹 명령행 인수 및 스크립트 활용:
   🔹 컨테이너 시작 인수 (args):
      • 동적 인수 생성
      • 환경변수 참조 활용
      • 복잡한 인수 구성
      • 스크립트 매개변수 전달
      • 조건부 인수 설정
   🔹 애플리케이션 옵션 전달:
      • 기능 플래그 전달
      • 디버그 모드 설정
      • 로그 레벨 조정
      • 성능 프로파일링
      • 사용자 정의 옵션
   🔹 스크립트 기반 설정:
      • 초기화 스크립트 실행
      • 설정 전처리 스크립트
      • 동적 설정 생성
      • 환경별 설정 선택
      • 설정 검증 및 정리
   🔹 런타임 설정 관리:
   🔹 애플리케이션 시작 시 설정 로드
   🔹 설정 변경 감지 및 업데이트
   🔹 핫 리로드 기능 지원
   🔹 설정 캐시 및 최적화
   🔹 오류 처리 및 복구

ConfigMap 생성 방법:
   🔹 명령형 생성:
      • kubectl create configmap
      • --from-literal 옵션
      • --from-file 옵션
      • --from-env-file 옵션
      • 빠른 프로토타이핑
      • 임시 설정 생성
   🔹 선언형 생성:
      • YAML 매니페스트
      • 버전 관리 가능
      • GitOps 워크플로우
      • 코드 리뷰 프로세스
      • 자동화 파이프라인
      • 재현 가능한 배포
   🔹 Kustomize 활용:
   🔹 환경별 설정 오버레이
   🔹 공통 설정 베이스
   🔹 패치 기반 커스터마이징
   🔹 설정 템플릿화
   🔹 복잡한 설정 관리

ConfigMap 업데이트 전략:
   🔹 롤링 업데이트:
      • ConfigMap 변경 감지
      • Pod 재시작 트리거
      • 점진적 설정 적용
      • 무중단 업데이트
      • 롤백 지원
      • 헬스 체크 통합
   🔹 불변 ConfigMap:
      • immutable 필드 설정
      • 설정 변경 방지
      • 캐시 효율성 향상
      • 예측 가능한 동작
      • 보안 강화
      • 성능 최적화
   🔹 버전 관리:
   🔹 ConfigMap 이름에 버전 포함
   🔹 블루-그린 배포 지원
   🔹 카나리 배포 활용
   🔹 A/B 테스트 지원
   🔹 빠른 롤백 가능
```

## 2. Secret 보안 관리 (12분)

### Secret 암호화 아키텍처

```mermaid
graph TB
    subgraph "Secret 생성"
        A[민감 데이터] --> B[Base64 인코딩]
        B --> C[Secret 객체]
    end
    
    subgraph "저장 및 암호화"
        C --> D[etcd 저장]
        D --> E[암호화 at Rest]
        E --> F[KMS 통합]
    end
    
    subgraph "Pod 사용"
        G[환경 변수] --> H[Container]
        I[볼륨 마운트] --> H
        J[이미지 풀 시크릿] --> K[kubelet]
    end
    
    C --> G
    C --> I
    C --> J
```

### Secret 상세 분석
```
Secret 보안 관리 아키텍처:

Secret 기본 개념:
   🔹 민감 정보 보호
   🔹 Base64 인코딩 저장
   🔹 네임스페이스 스코프
   🔹 RBAC 기반 접근 제어
   🔹 암호화 at Rest
   🔹 감사 로깅 지원

Secret 타입별 분류:
   🔹 Opaque (기본 타입):
      • 일반적인 민감 데이터
      • 데이터베이스 비밀번호
      • API 키 및 토큰
      • 암호화 키
      • 인증서 개인 키
      • 사용자 정의 데이터
   🔹 kubernetes.io/service-account-token:
      • 서비스 어카운트 토큰
      • API 서버 인증
      • 자동 생성 및 마운트
      • 토큰 순환 지원
      • RBAC 권한 연동
      • 만료 시간 관리
   🔹 kubernetes.io/dockercfg:
      • Docker 레지스트리 인증
      • 이미지 풀 시크릿
      • 프라이빗 레지스트리 접근
      • 다중 레지스트리 지원
      • 자동 인증 처리
      • 네임스페이스별 관리
   🔹 kubernetes.io/tls:
      • TLS 인증서 및 키
      • HTTPS 서비스 보안
      • Ingress TLS 종료
      • 서비스 간 mTLS
      • 인증서 자동 갱신
      • CA 인증서 체인
   🔹 kubernetes.io/ssh-auth:
   🔹 SSH 개인 키
   🔹 Git 저장소 접근
   🔹 원격 서버 인증
   🔹 CI/CD 파이프라인
   🔹 자동화 스크립트

Secret 보안 메커니즘:
   🔹 암호화 at Rest:
      • etcd 데이터 암호화
      • 암호화 키 관리
      • KMS 통합 지원
      • 키 순환 정책
      • 하드웨어 보안 모듈
      • 규정 준수 지원
   🔹 암호화 in Transit:
      • TLS 통신 보장
      • API 서버 보안
      • kubelet 통신 암호화
      • 네트워크 정책 적용
      • 서비스 메시 통합
      • 종단 간 암호화
   🔹 접근 제어:
      • RBAC 권한 관리
      • 네임스페이스 격리
      • 서비스 어카운트 제한
      • 최소 권한 원칙
      • 감사 로깅
      • 정책 기반 제어
   🔹 런타임 보안:
   🔹 메모리 내 보호
   🔹 임시 파일 시스템
   🔹 프로세스 격리
   🔹 컨테이너 보안
   🔹 노드 보안 강화

Secret 사용 모범 사례:
   🔹 생성 및 관리:
      • 외부 시크릿 관리 도구 사용
      • HashiCorp Vault 통합
      • AWS Secrets Manager 연동
      • Azure Key Vault 활용
      • 자동화된 시크릿 순환
      • 중앙화된 시크릿 관리
   🔹 배포 및 사용:
      • 환경별 시크릿 분리
      • 최소 권한 접근
      • 시크릿 스코프 제한
      • 임시 시크릿 사용
      • 감사 및 모니터링
      • 정기적 시크릿 검토
   🔹 보안 강화:
   🔹 시크릿 암호화 강화
   🔹 네트워크 정책 적용
   🔹 Pod 보안 정책
   🔹 컨테이너 이미지 스캔
   🔹 런타임 보안 모니터링
   🔹 침입 탐지 시스템
```

## 3. 설정 관리 모범 사례 (10분)

### 환경별 설정 전략

```mermaid
graph TB
    subgraph "개발 환경"
        A[dev-config] --> B[개발 DB]
        A --> C[디버그 로그]
    end
    
    subgraph "스테이징 환경"
        D[staging-config] --> E[스테이징 DB]
        D --> F[테스트 설정]
    end
    
    subgraph "프로덕션 환경"
        G[prod-config] --> H[프로덕션 DB]
        G --> I[최적화 설정]
    end
    
    subgraph "공통 설정"
        J[base-config] --> A
        J --> D
        J --> G
    end
```

### 설정 관리 전략
```
설정 관리 모범 사례:

환경별 분리 전략:
   🔹 베이스 설정 + 오버레이
   🔹 환경별 네임스페이스
   🔹 Kustomize 활용
   🔹 Helm 차트 템플릿
   🔹 GitOps 워크플로우

보안 고려사항:
   🔹 민감 정보 Secret 사용
   🔹 일반 설정 ConfigMap 사용
   🔹 접근 권한 최소화
   🔹 정기적 시크릿 순환
   🔹 감사 로깅 활성화

운영 효율성:
   🔹 자동화된 설정 배포
   🔹 설정 변경 추적
   🔹 롤백 전략 수립
   🔹 모니터링 및 알림
   🔹 문서화 및 표준화
```

## 4. 외부 시크릿 관리 도구 통합 (6분)

### 외부 도구 통합 아키텍처
```
외부 시크릿 관리 도구 통합:

HashiCorp Vault:
   🔹 동적 시크릿 생성
   🔹 시크릿 순환 자동화
   🔹 정책 기반 접근 제어
   🔹 감사 로깅
   🔹 다중 인증 방법

AWS Secrets Manager:
   🔹 관리형 시크릿 서비스
   🔹 자동 순환 지원
   🔹 IAM 통합
   🔹 암호화 키 관리
   🔹 비용 효율적

External Secrets Operator:
   🔹 외부 시크릿 동기화
   🔹 다중 백엔드 지원
   🔹 자동 갱신
   🔹 네이티브 Kubernetes 통합
   🔹 GitOps 친화적
```

## 5. 토론 및 정리 (2분)

### 핵심 키워드
- **설정 분리**: ConfigMap을 통한 코드-설정 분리
- **보안 관리**: Secret을 통한 민감 정보 보호
- **환경별 관리**: 환경별 설정 분리 전략
- **외부 통합**: 외부 시크릿 관리 도구 활용

### 다음 세션 예고
Session 8에서는 **Kubernetes 보안 기초**를 학습하여 **RBAC, 네트워크 정책, Pod 보안**을 다룹니다.